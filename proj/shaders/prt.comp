#version 450


layout(local_size_x=1, local_size_y=1, local_size_z=1) in;

layout(set=0, binding=0) buffer ShCoeffs
{
	vec3 shCoeffs[9];
} sb0;
layout(set=1, binding=0) uniform textureCube cubeMap;
layout(set=2, binding=0) uniform sampler clampSampler;

float evalSH9(vec3 dir, int index);
vec3 getCubemapDirection(int face, float u, float v);
float texelSolidAngle(float u, float v);
float atan2(in float y, in float x)
{
    return x == 0.0 ? sign(y)*3.141592f/2 : atan(y, x);
}

void main()
{
	uvec3 gtid = gl_GlobalInvocationID;
	
	vec3 coeff[9];
	
	for (int i = 0; i < 9; i++)
	{
		coeff[i] = vec3(0.0f);
	}

	for (int face = 0; face < 6; face++)
	{
		for (int y = 0; y < CUBEMAP_SIZE; y++)
		{
			for (int x = 0; x < CUBEMAP_SIZE; x++)
			{
				float u = float(x) / CUBEMAP_SIZE * 2.0f - 1.0f;
				float v = float(y) / CUBEMAP_SIZE * 2.0f - 1.0f;
			
				vec3 dir = getCubemapDirection(face, u, v);
			
				vec3 color = texture(samplerCube(cubeMap, clampSampler), dir).rgb;
				color = color / (color + vec3(1.0f));
				color = pow(color, vec3(1.0f / 2.2f));
			
				for (int i = 0; i < 9; i++)
				{
					float sh = evalSH9(dir, i);
			
					float b = sh;
				
					coeff[i] += color * b;
				}
			}
		}
	}

	for (int i = 0; i < 9; i++)
	{
		coeff[i] *= (4.0f * 3.141592f) / (CUBEMAP_SIZE * CUBEMAP_SIZE * 6);
		sb0.shCoeffs[i] = coeff[i];
	}
}


float evalSH9(vec3 dir, int index)
{
	float x = dir.x;
	float y = dir.y;
	float z = dir.z;
	
	float sh[9];
	
	sh[0] = 0.282095f;
	
	sh[1] = 0.488603f * y;
	sh[2] = 0.488603f * z;
	sh[3] = 0.488603f * x;
	
	sh[4] = 1.092548f * x * y;
	sh[5] = 1.092548f * y * z;
	sh[6] = 0.315392f * (3.0f * z * z - 1.0f);
	sh[7] = 1.092548f * x * z;
	sh[8] = 0.546274f * (x * x - y * y);
	
	return sh[index];
}

vec3 getCubemapDirection(int face, float u, float v)
{
	if (face == 0) return normalize(vec3(1, -v, -u));
	if (face == 1) return normalize(vec3(-1, -v, u));
	if (face == 2) return normalize(vec3(u, 1, v));
	if (face == 3) return normalize(vec3(u, -1, -v));
	if (face == 4) return normalize(vec3(u, -v, 1));
	if (face == 5) return normalize(vec3(-u, -v, -1));
	
	return vec3(0.0f);
}

float texelSolidAngle(float u, float v)
{
	float invSize = 1.0f / CUBEMAP_SIZE;
	float aU = u;
	float aV = v;
	float bU = u + invSize;
	float bV = v + invSize;

	float angle = atan2(aU * bV - bU * aV, aU * aU + aV * aV + 1.0f + bU * bU + bV * bV + 1.0f);
	return 4.0f * angle;
}
